Description of the Issue
In the "Step 3: Determine the Transaction Price" section, the AI's analysis is contradictory.

The narrative under "Detailed Analysis" point 1, "Fixed Consideration," states a total of $815,000.
It then lists the components: $720,000 (SaaS) + $50,000 (Hardware) + $75,000 (Services), which actually sum to $845,000.
Example from Memo:

Detailed Analysis:
1. Fixed Consideration
$815, 000, consisting of $720, 000 for the SaaS license over three years, $50, 000 for
hardware, and $75, 000 for professional services.

This is a logical error. The AI appears to have miscalculated the sum, likely by misinterpreting one of the fee structures from the contract text it was analyzing.

Analysis of Current Code
This problem arises from the AI's processing of the prompt in step_prompts.py, specifically get_user_prompt_for_step when step_number is 3.

The AI is asked to populate a JSON structure, including fields for fixed_consideration, variable_consideration, and total_transaction_price. It also generates analysis_points. The current process has two weaknesses:

Separation of Data: The structured transaction_price_components are generated separately from the narrative analysis_points. This allows for inconsistencies to creep in between the two parts.
Lack of Self-Correction: The prompt doesn't explicitly ask the AI to double-check its own math or ensure its narrative aligns with the structured data it generates.
Here is the relevant prompt section in step_prompts.py:

# In step_prompts.py, inside get_user_prompt_for_step, when step_number is 3:

# It asks for this JSON structure:
"{",
f'  "executive_conclusion": "...",',
f'  "{step_schema_name}": {step_schema_definition},', # This contains transaction_price_components
'  "professional_judgments": [ "..." ],',
'  "analysis_points": [ { "..." } ]', # This is generated separately
"}",

# And provides these critical rules:
"""<CRITICAL_INSTRUCTION>
- Your primary analysis MUST occur within the `transaction_price_components` JSON structure.
- Only use `analysis_points` for truly separate or unusual considerations not already covered by the standard components.
</CRITICAL_INSTRUCTION>"""

The "Fixed Consideration" narrative that contains the error is generated as one of the analysis_points. The rule to keep primary analysis in the JSON structure is good, but it's not enough to prevent this kind of error.

Proposed Changes
The best way to fix this is to use a formatting function that doesn't rely on the AI to create the narrative for the price components. Instead, we will programmatically generate the "Detailed Analysis" section for Step 3 using the structured JSON data the AI has already provided.

This approach, which I call the "Auditor's Method," ensures consistency because the narrative is built directly from the verified data, eliminating the possibility of contradictions. We'll modify the function format_step_detail_as_markdown.

Here are the step-by-step instructions:

Open the file: step_prompts.py
Navigate to the format_step_detail_as_markdown method. This function is responsible for turning the AI's JSON output into the markdown seen in the memo.
We need to add special logic for step_number == 3. We will create a new helper function for this and call it from the main one.
Instruction 1 of 2: Add a new helper function. Copy and paste the following new function above the format_step_detail_as_markdown method.

# PASTE THIS ENTIRE NEW FUNCTION INTO step_prompts.py

    @staticmethod
    def _format_step3_with_filtering(step_data: dict, step_name: str,
                                     conclusion: str,
                                     analysis_points: list) -> str:
        """
        Apply the Auditor's Method to Step 3: Merge structured components and
        analysis points into a single, consistently formatted list.
        """
        markdown_sections = [
            f"### Step 3: {step_name}", f"**Conclusion:**\n{conclusion}",
            "**Detailed Analysis:**\n"
        ]

        all_points = []
        transaction_components = step_data.get('step3_analysis', {}).get('transaction_price_components', {})
        title_map = {
            'total_transaction_price': 'Total Transaction Price', 'fixed_consideration': 'Fixed Consideration',
            'variable_consideration': 'Variable Consideration', 'financing_component_analysis': 'Significant Financing Component',
            'noncash_consideration_analysis': 'Noncash Consideration', 'consideration_payable_to_customer_analysis': 'Consideration Payable to Customer',
            'other_considerations_analysis': 'Other Considerations'
        }
        processed_values = set()

        for key, analysis_text in transaction_components.items():
            is_not_applicable = (not analysis_text or str(analysis_text).strip().lower() in ('n/a', 'not applicable', '') or
                               str(analysis_text).strip().lower().startswith('n/a') or len(str(analysis_text).strip()) < 3)
            if not is_not_applicable:
                text_str = str(analysis_text).strip()
                if key in ['fixed_consideration', 'total_transaction_price']:
                    if text_str in processed_values: continue
                    processed_values.add(text_str)
                    if len(text_str) < 30: continue
                topic_title = title_map.get(key, key.replace('_', ' ').title())
                all_points.append({'topic_title': topic_title, 'analysis_text': analysis_text, 'evidence_quotes': []})

        if analysis_points:
            all_points.extend(analysis_points)

        if not all_points:
            markdown_sections.append("Only basic fixed consideration was identified in this contract.")
        else:
            for i, point in enumerate(all_points):
                markdown_sections.append(f"**{i+1}. {point.get('topic_title', 'Analysis Point')}**")
                markdown_sections.append(str(point.get('analysis_text', 'No analysis text provided.')))
                if evidence_quotes := point.get('evidence_quotes', []):
                    if isinstance(evidence_quotes, list):
                        for quote in evidence_quotes:
                            if isinstance(quote, str) and quote:
                                markdown_sections.append(f"> {quote}")

        final_content = [section for section in markdown_sections if str(section).strip()]
        return "\n\n".join(final_content)

Instruction 2 of 2: Modify the existing function. Now, modify the format_step_detail_as_markdown function to call the new helper function we just added.

This is the function you need to modify:

# BEFORE THE CHANGE:
    @staticmethod
    def format_step_detail_as_markdown(step_data: dict, step_number: int,
                                       step_name: str) -> str:
        """Format step analysis from narrative JSON structure into professional markdown."""
        if not step_data or not isinstance(step_data, dict):
            return f"### Step {step_number}: {step_name}\n\nNo analysis data was returned for this step.\n"

        conclusion = step_data.get('executive_conclusion',
                                   'No conclusion was provided.')
        analysis_points = step_data.get('analysis_points', [])
        # ... more code ...

Instruction: Add the if step_number == 3: block to the top of the function.

# AFTER THE CHANGE:
    @staticmethod
    def format_step_detail_as_markdown(step_data: dict, step_number: int,
                                       step_name: str) -> str:
        """Format step analysis from narrative JSON structure into professional markdown."""
        if not step_data or not isinstance(step_data, dict):
            return f"### Step {step_number}: {step_name}\n\nNo analysis data was returned for this step.\n"

        conclusion = step_data.get('executive_conclusion',
                                   'No conclusion was provided.')
        analysis_points = step_data.get('analysis_points', [])

        # Route to the correct helper function based on step number
        if step_number == 2:
            return StepPrompts._format_step2_with_filtering(
                step_data, step_name, conclusion, analysis_points)
        elif step_number == 3: # THIS IS THE NEW PART
            return StepPrompts._format_step3_with_filtering(
                step_data, step_name, conclusion, analysis_points)
        elif step_number in [1, 4, 5]:
            return StepPrompts._format_general_step_with_filtering(
                step_data, step_name, conclusion, analysis_points, step_number)

        # ... rest of the function

This change forces Step 3's output to be built directly from the structured transaction_price_components data, completely eliminating the possibility of the AI creating a contradictory narrative. This is a much more robust and reliable approach.