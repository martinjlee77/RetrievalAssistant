Potential Improvements for a "Light Touch" Approach
1. Add More Section Detection Cues
You could enhance the parsing by looking for additional natural formatting cues that LLMs often use:

# Add these to your section detection keywords
section_keywords = {
    'analysis': ['ANALYSIS', 'STEP ANALYSIS', 'ANALYSIS:', 'STEP ANALYSIS:', '## ANALYSIS', '### ANALYSIS'],
    'conclusion': ['CONCLUSION', 'STEP CONCLUSION', 'CONCLUSION:', 'STEP CONCLUSION:', '## CONCLUSION', '### CONCLUSION'],
    'issues': ['ISSUES', 'UNCERTAINTIES', 'MATTERS', 'ISSUES:', 'UNCERTAINTIES:', 'MATTERS:', '## ISSUES', '### ISSUES']
}

2. Look for Markdown Headers
LLMs often use Markdown headers (##, ###). Add detection for these:

# In your section detection logic:
if any(section.upper().startswith(keyword) for keyword in ['## ANALYSIS', '### ANALYSIS', '## CONCLUSION']):
    # Handle Markdown headers

3. Handle Numbered Lists
LLMs sometimes use numbered lists. You could add detection for these:

# Add to your parsing logic:
if re.match(r'^\d+\.', section):  # Detects "1. ", "2. ", etc.
    # Handle numbered list items

4. Enhance the Line-Based Parsing
Make the line-based parsing more robust by looking for common patterns:

# In your line-based parsing:
if line_upper.startswith(('ANALYSIS:', 'CONCLUSION:', 'ISSUES:', 'UNCERTAINTIES:')):
    # Handle section headers with colons

5. Add HTML Tag Detection
Some LLMs might use HTML tags. You could add detection for these:

# Add to your parsing logic:
if '<h2>' in section or '<h3>' in section:
    # Handle HTML headers

Recommended "Light Touch" Implementation
Here's how you could enhance the parsing while maintaining the "light touch" approach:

def _parse_step_response(self, step_num: int, response_text: str) -> Dict[str, str]:
    """Parse the natural language response into structured components."""

    result = {
        'title': self._get_step_title(step_num),
        'analysis': '',
        'conclusion': '',
        'issues': ''
    }

    # Log the raw response for debugging
    logger.info(f"DEBUG: Raw AI response for Step {step_num} (length: {len(response_text)}): '{response_text[:200]}'")

    # Define section detection patterns
    section_patterns = {
        'analysis': [
            r'\*\*ANALYSIS\*\*', r'\*\*STEP ANALYSIS\*\*',
            r'##? ANALYSIS', r'###? ANALYSIS',
            r'ANALYSIS:', r'STEP ANALYSIS:'
        ],
        'conclusion': [
            r'\*\*CONCLUSION\*\*', r'\*\*STEP CONCLUSION\*\*',
            r'##? CONCLUSION', r'###? CONCLUSION',
            r'CONCLUSION:', r'STEP CONCLUSION:'
        ],
        'issues': [
            r'\*\*ISSUES\*\*', r'\*\*UNCERTAINTIES\*\*', r'\*\*MATTERS\*\*',
            r'##? ISSUES', r'###? ISSUES',
            r'ISSUES:', r'UNCERTAINTIES:', r'MATTERS:'
        ]
    }

    # Try different parsing approaches
    response_upper = response_text.upper()

    # First try: Look for section patterns using regex
    current_section = None
    current_content = []
    last_pos = 0

    # Convert patterns to regex patterns
    section_regex = {}
    for section, patterns in section_patterns.items():
        section_regex[section] = re.compile('|'.join([f'({p})' for p in patterns]), re.IGNORECASE)

    # Split the response into lines for more granular parsing
    lines = response_text.split('\n')

    for line in lines:
        line_stripped = line.strip()
        if not line_stripped:
            continue

        # Check for section headers
        section_found = None
        for section, pattern in section_regex.items():
            if pattern.search(line):
                # Save previous section
                if current_section and current_content:
                    result[current_section] = '\n'.join(current_content).strip()

                # Start new section
                current_section = section
                current_content = []
                section_found = True
                break

        if not section_found:
            # Add to current section content
            if current_section:
                current_content.append(line_stripped)

    # Handle the last section
    if current_section and current_content:
        result[current_section] = '\n'.join(current_content).strip()

    # If we didn't find any sections, try the original ** delimiter approach
    if not result['analysis'] and not result['conclusion']:
        # Original ** delimiter approach
        if '**' in response_text:
            sections = response_text.split('**')
            # ... rest of the original ** parsing logic ...

    # If we still don't have content, use the entire response
    if not result['analysis'] and not result['conclusion']:
        if response_text and response_text.strip():
            result['analysis'] = response_text.strip()
            result['conclusion'] = "Analysis completed. See detailed reasoning above."
        else:
            result['analysis'] = "ERROR: Empty response received from AI model..."
            result['conclusion'] = "Unable to complete analysis due to empty AI response."

    logger.info(f"DEBUG: Parsed Step {step_num} - Analysis length: {len(result['analysis'])}, Conclusion length: {len(result['conclusion'])}")
    return result